#pragma once

#include <memory>
#include <vector>
#include <ctime>
#include <sys/time.h>
#include <string.h>
#include <set>
#include <map>
#include <sstream>
#include <mutex>

#include "Bootstrap.hpp"
#include "Utils.hpp"
#include "Topic.hpp"
#include "Scope.hpp"
#include "Type/Timestamp.hpp"

IRSTD_TOPIC_USE(IrStd, None);
IRSTD_SCOPE_USE(IrStdMemoryNoTrace);

/**
 * Supports the following arguments:
 * IRSTD_LOG("hello")
 * IRSTD_LOG(level, "hello")
 * IRSTD_LOG(level, IrStd, "hello")
 * IRSTD_LOG(logger, level, IrStd, "hello")
 */
#define IRSTD_LOG_TRACE(...) IRSTD_LOG(IrStd::Logger::Level::Trace, __VA_ARGS__)
#define IRSTD_LOG_DEBUG(...) IRSTD_LOG(IrStd::Logger::Level::Debug, __VA_ARGS__)
#define IRSTD_LOG_INFO(...) IRSTD_LOG(IrStd::Logger::Level::Info, __VA_ARGS__)
#define IRSTD_LOG_WARNING(...) IRSTD_LOG(IrStd::Logger::Level::Warning, __VA_ARGS__)
#define IRSTD_LOG_ERROR(...) IRSTD_LOG(IrStd::Logger::Level::Error, __VA_ARGS__)
#define IRSTD_LOG_FATAL(...) IRSTD_LOG(IrStd::Logger::Level::Fatal, __VA_ARGS__)

/**
 * \brief Generic logging function
 *
 * It disabled any memory logging generated by this specific call.
 */
#define IRSTD_LOG(...) IRSTD_GET_MACRO(_IRSTD_LOG, __VA_ARGS__)(__VA_ARGS__)

#define _IRSTD_LOG1(message) __IRSTD_LOG_NOARG(message)
#define _IRSTD_LOG2(arg1, message) __IRSTD_LOG(message, arg1)
#define _IRSTD_LOG3(arg1, arg2, message) __IRSTD_LOG(message, arg1, arg2)
#define _IRSTD_LOG4(arg1, arg2, arg3, message) __IRSTD_LOG(message, arg1, arg2, arg3)

#define __IRSTD_LOG(message, ...) \
	if (!IrStd::Logger::isIgnoredStatic(__VA_ARGS__)) \
	{ \
		IRSTD_SCOPE(irstdLoggerScope, IrStd::Flag::IrStdMemoryNoTrace); \
		*IrStd::Logger::entryStatic(__LINE__, (strrchr(__FILE__, '/') ? \
				strrchr(__FILE__, '/') + 1 : __FILE__), __func__, __VA_ARGS__) << message; \
	}

#define __IRSTD_LOG_NOARG(message) \
	if (!IrStd::Logger::isIgnoredStatic()) \
	{ \
		IRSTD_SCOPE(irstdLoggerScope, IrStd::Flag::IrStdMemoryNoTrace); \
		*IrStd::Logger::entryStatic(__LINE__, (strrchr(__FILE__, '/') ? \
				strrchr(__FILE__, '/') + 1 : __FILE__), __func__) << message; \
	}

/**
 * This flag will make the trace always be printed regardless of the topic selected,
 * unless a higher trace level is sepcified.
 */
#define IRSTD_LOGGER_NON_MASKABLE 0x10000

#define IRSTD_LOGGER_DEFINE_LEVEL(...) IRSTD_GET_MACRO(_IRSTD_LOGGER_DEFINE_LEVEL, __VA_ARGS__)(__VA_ARGS__)
#define _IRSTD_LOGGER_DEFINE_LEVEL2(verbosity, id) _IRSTD_LOGGER_DEFINE_LEVEL3(verbosity, id, 0)
#define _IRSTD_LOGGER_DEFINE_LEVEL3(verbosity, id, flags) \
		(static_cast<uint16_t>(id) | static_cast<uint32_t>((0xfff & verbosity) << 20) \
		| static_cast<uint32_t>(0xf0000 & flags))

namespace IrStd
{
	class Logger
	{
	public:
		enum class Level : uint32_t
		{
			/**
			 * Designates finer-grained informational events than the DEBUG.
			 */
			Trace = IRSTD_LOGGER_DEFINE_LEVEL(0x001, 't'),
			/**
			 * Designates fine-grained informational events that are most useful to debug an application.
			 */
			Debug = IRSTD_LOGGER_DEFINE_LEVEL(0x002, 'd'),
			/**
			 * Designates informational messages that highlight the progress of the application at coarse-grained level.
			 */
			Info = IRSTD_LOGGER_DEFINE_LEVEL(0x004, 'i'),
			/**
			 * Designates potentially harmful situations.
			 */
			Warning = IRSTD_LOGGER_DEFINE_LEVEL(0x008, 'w'),
			/**
			 * Designates error events that might still allow the application to continue running.
			 * This level and above levels cannot be masked (hence they will always be displayed).
			 */
			Error = IRSTD_LOGGER_DEFINE_LEVEL(0x010, 'e', IRSTD_LOGGER_NON_MASKABLE),
			/**
			 * Designates very severe error events that will presumably lead the application to abort.
			 */
			Fatal = IRSTD_LOGGER_DEFINE_LEVEL(0x020, 'f', IRSTD_LOGGER_NON_MASKABLE)
		};

		inline static char levelToChar(Level level) noexcept
		{
			const uint32_t l = static_cast<uint32_t>(level);
			return static_cast<const char>(l & 0xff);
		}

		struct Info
		{
			Info(const Level level, const TopicImpl& topic, const size_t line, const char* const file, const char* const func)
				: m_level(level), m_topic(topic), m_line(line), m_file(file), m_func(func)
			{
			}
			const Level m_level;
			const TopicImpl& m_topic;
			const size_t m_line;
			const char* const m_file;
			const char* const m_func;
			Type::Timestamp m_time;
		};

		/**
		 * \brief Stream formater
		 */
		class Format
		{
		public:
			typedef std::function<void(std::ostream&, const Info&, const std::string&)> Type;

			static void standard(std::ostream&, const Info&, const std::string&);
			static void raw(std::ostream&, const Info&, const std::string&);
		};

		/**
		 * \brief Stream filter
		 */
		class Filter
		{
		public:
			Filter(const Level minLevel = Level::Error)
					: m_minLevel(minLevel)

			{
			}

			Filter(const Filter& filter)
			{
				*this = filter;
			}

			void operator=(const Filter& filter)
			{
				std::lock_guard<std::mutex> lock1(m_mutex);
				std::lock_guard<std::mutex> lock2(filter.m_mutex);
				m_minLevel = filter.m_minLevel;
				m_topics = filter.m_topics;
			}

			void setLevel(const Level minLevel) noexcept
			{
				m_minLevel = minLevel;
			}

			void allTopics() noexcept
			{
				// Cannot print any logs as it make use of the logger which is currenlty
				// deleting all its topics. Accessing 
				IRSTD_SCOPE(scope, IrStd::Flag::IrStdMemoryNoTrace);
				std::lock_guard<std::mutex> lock(m_mutex);
				m_topics.clear();
			}

			void addTopic(const TopicImpl& topic, const Level minLevel) noexcept
			{
				// Cannot print any logs as it make use of the logger which is locked
				// as it is currenlty accessing the filter object
				IRSTD_SCOPE(scope, IrStd::Flag::IrStdMemoryNoTrace);
				std::lock_guard<std::mutex> lock(m_mutex);
				m_topics.insert({topic.getRef(), minLevel});
			}

			bool isIgnored(const Level level, const TopicImpl& topic) noexcept
			{
				// Check if this is non maskable
				if (static_cast<uint32_t>(level) & IRSTD_LOGGER_NON_MASKABLE
						&& m_minLevel <= level)
				{
					return false;
				}

				// Filter on topics
				if (!m_topics.empty())
				{
					const auto* pTopic = &topic;
					while (pTopic)
					{
						std::lock_guard<std::mutex> lock(m_mutex);
						{
							const auto it = m_topics.find(pTopic->getRef());
							if (it != m_topics.end())
							{
								if (it->second <= level)
								{
									return false;
								}
								return true;
							}
						}
						pTopic = pTopic->getParent();
					}
				}

				// Filter on level
				if (level >= m_minLevel)
				{
					return false;
				}

				// If no topic are in the filter list, accept everything
			//	if (m_topics.empty())
			//	{
			//		return false;
			//	}

				return true;
			}
		private:
			Level m_minLevel;
			std::map<TopicImpl::Ref, Level> m_topics;
			mutable std::mutex m_mutex;
		};

		/**
		 * \brief Data structure that defines a stream
		 */
		struct Stream
		{
			/**
			 * Constructors
			 */
			Stream(std::ostream& os)
					: Stream(os, Format::standard)
			{
			}
			Stream(std::ostream& os, const Format::Type& format)
					: m_os(os)
					, m_format(format)
					, m_hasFilter(false)
			{
			}
			Stream(std::ostream& os, const Filter& filter)
					: Stream(os, Format::standard, filter)
			{
			}
			Stream(std::ostream& os, const Format::Type& format, const Filter& filter)
					: m_os(os)
					, m_format(format)
					, m_filter(filter)
					, m_hasFilter(true)
			{
			}

			std::ostream& m_os;
			const Format::Type m_format;
			Filter m_filter;
			const bool m_hasFilter;
		};

		typedef std::vector<Stream> StreamList;

		class OutputStream
		{
		public:
			OutputStream() = delete;
			/**
			 * 
			 */
			explicit OutputStream(const OutputStream& os) = default;
			OutputStream(const Filter m_filter, StreamList& streamList, const Info& info);

			/**
			 * Move constructor
			 */
			OutputStream(const OutputStream&& os);

			/**
			 * Used to unlock the mutex
			 */
			~OutputStream();

			template<typename T>
			OutputStream& operator<<(const T& in)
			{
				m_bufferStream << in;
				return *this;
			}

			template<typename T>
			OutputStream& operator<<(T& in)
			{
				m_bufferStream << in;
				return *this;
			}

		private:
			Filter m_filter;
			StreamList& m_streamList;
			const Info m_info;

			std::string m_buffer;
			std::stringstream m_bufferStream;
		};

		typedef std::unique_ptr<OutputStream> OutputStreamPtr;

		/**
		 * Constructors
		 */
		Logger();
		explicit Logger(const Stream& stream);

		/**
		 * Copy constructors
		 */
		Logger(const Logger& logger);
		void operator=(const Logger& logger);

		/**
		 * This is used for the default logger.
		 * This logger is always present and is used by all
		 * the macros LOG_xxx
		 */
		static Logger& getDefault();	

		/**
		 * Add a stream to the logger
		 */
		void addStream(const Stream& stream);

		/**
		 * Checks if the entry information should be ignored or not
		 */
		bool isIgnored(const Level level, const TopicImpl& topic) noexcept;

		/**
		 * Set the minimum trace level for the whole logger 
		 */
		void setLevel(const Level minLevel) noexcept;

		/**
		 * View all topics
		 */
		void allTopics() noexcept;

		/**
		 * Add a new topic to the filter list
		 */
		void addTopic(const TopicImpl& topic, const Level minLevel = Level::Trace) noexcept;

		OutputStreamPtr entry(const size_t line, const char* const file, const char* const func, const Level level, const TopicImpl& topic);

		static bool isIgnoredStatic(Logger& logger, const Level level = IrStd::Logger::Level::Info, const TopicImpl& topic = IRSTD_TOPIC(IrStd, None)) noexcept;
		static bool isIgnoredStatic(Logger& logger, const TopicImpl& topic, const Level level = IrStd::Logger::Level::Info) noexcept;
		static bool isIgnoredStatic(const TopicImpl& topic = IRSTD_TOPIC(IrStd, None), const Level level = IrStd::Logger::Level::Info) noexcept;
		static bool isIgnoredStatic(const Level level, const TopicImpl& topic = IRSTD_TOPIC(IrStd, None)) noexcept;
		static bool isIgnoredStatic(const Level level, Logger& logger, const TopicImpl& topic = IRSTD_TOPIC(IrStd, None)) noexcept;

		static OutputStreamPtr entryStatic(const size_t line, const char* const file, const char* const func, Logger& logger,
				const Level level = IrStd::Logger::Level::Info, const TopicImpl& topic = IRSTD_TOPIC(IrStd, None));
		static OutputStreamPtr entryStatic(const size_t line, const char* const file, const char* const func, Logger& logger,
				const TopicImpl& topic, const Level level = IrStd::Logger::Level::Info);
		static OutputStreamPtr entryStatic(const size_t line, const char* const file, const char* const func,
				const TopicImpl& topic = IRSTD_TOPIC(IrStd, None), const Level level = IrStd::Logger::Level::Info);
		static OutputStreamPtr entryStatic(const size_t line, const char* const file, const char* const func,
				const Level level, const TopicImpl& topic = IRSTD_TOPIC(IrStd, None));
		static OutputStreamPtr entryStatic(const size_t line, const char* const file, const char* const func,
				const Level level, Logger& logger, const TopicImpl& topic = IRSTD_TOPIC(IrStd, None));

	private:
		friend Bootstrap;

		static void disable() noexcept;

		StreamList m_streamList;
		Filter m_filter;
		static bool m_globalEnable;
	};
}
