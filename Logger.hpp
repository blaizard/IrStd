#pragma once

#include <memory>
#include <vector>
#include <ctime>
#include <sys/time.h>
#include <string.h>
#include <set>
#include <sstream>

#include "Utils.hpp"
#include "Topic.hpp"
#include "Allocator.hpp"
#include "Scope.hpp"

IRSTD_TOPIC_USE(None);
IRSTD_SCOPE_THREAD_USE(IrStdMemoryNoTrace);

/**
 * Supports the following arguments:
 * IRSTD_LOG("hello")
 * IRSTD_LOG(level, "hello")
 * IRSTD_LOG(level, IrStdMemoryNoTrace, "hello")
 */
#define IRSTD_LOG_TRACE(...) IRSTD_LOG(IrStd::Logger::Level::Trace, __VA_ARGS__)
#define IRSTD_LOG_DEBUG(...) IRSTD_LOG(IrStd::Logger::Level::Debug, __VA_ARGS__)
#define IRSTD_LOG_INFO(...) IRSTD_LOG(IrStd::Logger::Level::Info, __VA_ARGS__)
#define IRSTD_LOG_WARNING(...) IRSTD_LOG(IrStd::Logger::Level::Warning, __VA_ARGS__)
#define IRSTD_LOG_ERROR(...) IRSTD_LOG(IrStd::Logger::Level::Error, __VA_ARGS__)
#define IRSTD_LOG_FATAL(...) IRSTD_LOG(IrStd::Logger::Level::Fatal, __VA_ARGS__)

#define IRSTD_LOG(...) IRSTD_GET_MACRO(_IRSTD_LOG, __VA_ARGS__)(__VA_ARGS__)

#define _IRSTD_LOG1(message) __IRSTD_LOG(IrStd::Logger::getDefault(), message, IrStd::Logger::Level::Info, IrStd::Topic::None)
#define _IRSTD_LOG2(level, message) __IRSTD_LOG(IrStd::Logger::getDefault(), message, level, IrStd::Topic::None)
#define _IRSTD_LOG3(level, topic, message) __IRSTD_LOG(IrStd::Logger::getDefault(), message, level, topic)

#define IRSTD_LOG_TRACE_X(logger, ...) IRSTD_LOG_X(logger, IrStd::Logger::Level::Trace, __VA_ARGS__)
#define IRSTD_LOG_DEBUG_X(logger, ...) IRSTD_LOG_X(logger, IrStd::Logger::Level::Debug, __VA_ARGS__)
#define IRSTD_LOG_INFO_X(logger, ...) IRSTD_LOG_X(logger, IrStd::Logger::Level::Info, __VA_ARGS__)
#define IRSTD_LOG_WARNING_X(logger, ...) IRSTD_LOG_X(logger, IrStd::Logger::Level::Warning, __VA_ARGS__)
#define IRSTD_LOG_ERROR_X(logger, ...) IRSTD_LOG_X(logger, IrStd::Logger::Level::Error, __VA_ARGS__)
#define IRSTD_LOG_FATAL_X(logger, ...) IRSTD_LOG_X(logger, IrStd::Logger::Level::Fatal, __VA_ARGS__)

#define IRSTD_LOG_X(...) IRSTD_GET_MACRO(_IRSTD_LOG_X, __VA_ARGS__)(__VA_ARGS__)

#define _IRSTD_LOG_X2(logger, message) __IRSTD_LOG(logger, message, IrStd::Logger::Level::Info, IrStd::Topic::None)
#define _IRSTD_LOG_X3(logger, level, message) __IRSTD_LOG(logger, message, level, IrStd::Topic::None)
#define _IRSTD_LOG_X4(logger, level, topic, message) __IRSTD_LOG(logger, message, level, topic)

/**
 * \brief Generic logging function
 *
 * It disabled any memory logging generated by this specific call.
 */
#define __IRSTD_LOG(logger, message, level, topic) \
	if (!logger.isIgnored(level, topic)) \
	{ \
		IRSTD_SCOPE_THREAD(scope, IrStdMemoryNoTrace); \
		*(logger).entry(__LINE__, (strrchr(__FILE__, '/') ? \
				strrchr(__FILE__, '/') + 1 : __FILE__), __func__, level, topic) << message; \
	}

#define IRSTD_LOGGER_DEFINE_LEVEL(verbosity, id) (static_cast<uint32_t>(verbosity << 16) | static_cast<uint16_t>(id))

namespace IrStd
{
	class Logger
	{
	public:
		enum class Level : uint32_t
		{
			/**
			 * Designates finer-grained informational events than the DEBUG.
			 */
			Trace = IRSTD_LOGGER_DEFINE_LEVEL(0x0001, 't'),
			/**
			 * Designates fine-grained informational events that are most useful to debug an application.
			 */
			Debug = IRSTD_LOGGER_DEFINE_LEVEL(0x0002, 'd'),
			/**
			 * Designates informational messages that highlight the progress of the application at coarse-grained level.
			 */
			Info = IRSTD_LOGGER_DEFINE_LEVEL(0x0004, 'i'),
			/**
			 * Designates potentially harmful situations.
			 */
			Warning = IRSTD_LOGGER_DEFINE_LEVEL(0x0008, 'w'),
			/**
			 * Designates error events that might still allow the application to continue running.
			 */
			Error = IRSTD_LOGGER_DEFINE_LEVEL(0x0010, 'e'),
			/**
			 * Designates very severe error events that will presumably lead the application to abort.
			 */
			Fatal = IRSTD_LOGGER_DEFINE_LEVEL(0x0020, 'f')
		};

		struct Info
		{
			Info(const Level level, const TopicImpl& topic, const size_t line, const char* const file, const char* const func)
				: m_level(level), m_topic(topic), m_line(line), m_file(file), m_func(func)
			{
			}
			const Level m_level;
			const TopicImpl& m_topic;
			const size_t m_line;
			const char* const m_file;
			const char* const m_func;
			timeval m_time;
		};

		/**
		 * \brief Stream formater
		 */
		class Format
		{
		public:
			virtual void header(std::ostream& out, const Info& info) const = 0;
			virtual void tail(std::ostream& out) const = 0;
		};

		class FormatRaw : public Format, public SingletonImpl<FormatRaw>
		{
		public:
			void header(std::ostream& out, const Info& info) const;
			void tail(std::ostream& out) const;
		};

		class FormatDefault : public Format, public SingletonImpl<FormatDefault>
		{
		public:
			void header(std::ostream& out, const Info& info) const;
			void tail(std::ostream& out) const;
		};

		/**
		 * \brief Stream filter
		 */
		class Filter
		{
		public:
			Filter(const Level minLevel = Level::Trace)
				: m_minLevel(minLevel)
			{
			}

			void setLevel(const Level minLevel) noexcept
			{
				m_minLevel = minLevel;
			}

			void addTopic(const TopicImpl& topic) noexcept
			{
				m_onlyTopics.insert(&topic);
			}

			bool isIgnored(const Level level, const TopicImpl& topic) const noexcept
			{
				// Filter on level
				if (m_minLevel > level)
				{
					return true;
				}
				// Filter on topics
				if (!m_onlyTopics.empty() && m_onlyTopics.find(&topic) == m_onlyTopics.end())
				{
					return true;
				}
				return false;
			}
		private:
			Level m_minLevel;
			std::set<const TopicImpl*> m_onlyTopics;
		};

		/**
		 * \brief Data structure that defines a stream
		 */
		struct Stream
		{
			/**
			 * Constructors
			 */
			Stream(std::ostream& os)
					: Stream(os, &FormatDefault::getInstance(), Filter())
			{
			}
			Stream(std::ostream& os, const Format* const pFormat)
					: Stream(os, pFormat, Filter())
			{
			}
			Stream(std::ostream& os, const Filter& filter)
					: Stream(os, &FormatDefault::getInstance(), filter)
			{
			}
			Stream(std::ostream& os, const Format* const pFormat, const Filter& filter)
					: m_os(os), m_pFormat(pFormat), m_filter(filter)
			{
			}

			/**
			 * Copy constructors
			 */
			Stream(const Stream& stream)
					: m_os(stream.m_os), m_pFormat(stream.m_pFormat), m_filter(stream.m_filter)
			{
			}

			std::ostream& m_os;
			const Format* const m_pFormat;
			const Filter m_filter;
		};

		typedef std::vector<Stream, AllocatorObj<Stream, AllocatorRaw>> StreamList;
		//typedef std::vector<Stream> StreamList;

		class OutputStream
		{
		public:
			OutputStream() = delete;
			/**
			 * 
			 */
			explicit OutputStream(const OutputStream& os) = default;
			OutputStream(const StreamList& streamList, const Info& info);

			/**
			 * Move constructor
			 */
			OutputStream(const OutputStream&& os);

			/**
			 * Used to unlock the mutex
			 */
			~OutputStream();

			template<typename T>
			OutputStream& operator<<(const T& in)
			{
				m_bufferStream << in;
				return *this;
			}

		private:
			const StreamList& m_streamList;
			const Info m_info;

			std::string m_buffer;
			std::stringstream m_bufferStream;
		};

		//typedef std::unique_ptr<OutputStream, std::function<void(OutputStream*)>> OutputStreamPtr;
		typedef IrStd::UniquePtr<AllocatorRaw, OutputStream> OutputStreamPtr;

		/**
		 * Constructors
		 */
		Logger() = default;
		explicit Logger(const Stream& stream);

		/**
		 * Copy constructors
		 */
		Logger(const Logger& logger);
		void operator=(Logger const& logger);

		/**
		 * This is used for the default logger.
		 * This logger is always present and is used by all
		 * the macros LOG_xxx
		 */
		static Logger& getDefault();	

		/**
		 * Add a stream to the logger
		 */
		void addStream(const Stream& stream);

		/**
		 * Checks if the entry information should be ignored or not
		 */
		bool isIgnored(const Level level, const TopicImpl& topic) const noexcept;

		/**
		 * Set the minimum trace level for the whole logger 
		 */
		void setLevel(const Level minLevel) noexcept;

		/**
		 * Add a new topic to the filter list
		 */
		void addTopic(const TopicImpl& topic) noexcept;

		OutputStreamPtr entry(const size_t line, const char* const file, const char* const func, const Level level, const TopicImpl& topic);

	private:
		StreamList m_streamList;
		Filter m_filter;
	};
}
